
-- Server_Part2
-- Contiene la segunda mitad del archivo original: movimiento, spawn loop, creación de bases,
-- mapa, comandos admin, income loop, inicialización final, etc.
-- IMPORTANTE: este script toma las variables/funciones exportadas por Server_Part1 vía _G.Brainrots_Share.
-- MODIFICADO: Se cambió el material de DiamondPlate al estilo clásico de Roblox (Plastic con Studs).

-- Recuperar las variables compartidas exportadas por la Parte1
local share = _G.Brainrots_Share or {}
local Players = share.Players or game:GetService("Players")
local Workspace = share.Workspace or game:GetService("Workspace")
local TweenService = share.TweenService or game:GetService("TweenService")
local RunService = share.RunService or game:GetService("RunService")
local ReplicatedStorage = share.ReplicatedStorage or game:GetService("ReplicatedStorage")
local Debris = share.Debris or game:GetService("Debris")
local MarketplaceService = share.MarketplaceService or game:GetService("MarketplaceService")
local Lighting = game:GetService("Lighting")

-- NUEVO: Evento para ejecutar comandos desde el menú de admin
local ExecuteAdminCommandEvent = Instance.new("RemoteEvent", ReplicatedStorage)
ExecuteAdminCommandEvent.Name = "ExecuteAdminCommandEvent"

local SpeedBoostEvent = share.SpeedBoostEvent
local InvisibilityEvent = share.InvisibilityEvent
local AdminAbuseEvent = share.AdminAbuseEvent
local BrazilianDiscoEvent = share.BrazilianDiscoEvent

local BASE_SIZE = share.BASE_SIZE
local FRUIT_SIZE = share.FRUIT_SIZE
local WALK_SPEED = share.WALK_SPEED
local LOCK_LASER_TIME = share.LOCK_LASER_TIME
local FREE_BOOST_DURATION = share.FREE_BOOST_DURATION
local SPEED_BOOST_AMOUNT = share.SPEED_BOOST_AMOUNT
local FRUIT_SPAWN_DELAY = share.FRUIT_SPAWN_DELAY
local TRANSIT_TIME = share.TRANSIT_TIME
local GUIDE_ARROW_DURATION = share.GUIDE_ARROW_DURATION
local LEADERBOARD_UPDATE_INTERVAL = share.LEADERBOARD_UPDATE_INTERVAL

local ADMIN_USERNAMES = share.ADMIN_USERNAMES
local RARITIES = share.RARITIES
local nextFruitID = share.nextFruitID

local basesFolder = share.basesFolder or (Instance.new("Folder", Workspace) and nil)
local fruitsFolder = share.fruitsFolder
local mapFolder = share.mapFolder

local playerData = share.playerData or {}
local baseCount = share.baseCount or 0
local fruitsInTransit = share.fruitsInTransit or {}
local isSpawning = share.isSpawning or false

local brazilianDiscoActive = share.brazilianDiscoActive or false
local discoLights = share.discoLights or {}
local originalColors = share.originalColors or {}
local deathEventActive = false -- Nueva variable para controlar el Evento de la Muerte
local crabSpawnLoopActive = false -- NUEVO: controla el spawn de cangrejos

local BASE_POSITIONS = share.BASE_POSITIONS
local FRUIT_SPAWN_POINT = share.FRUIT_SPAWN_POINT
local FRUIT_END_POINT = share.FRUIT_END_POINT

-- Se añaden los nuevos Sound IDs
local SOUND_IDS = share.SOUND_IDS or {}
SOUND_IDS.FireworkLaunch = "rbxassetid://1289184659"
SOUND_IDS.DeathEventMusic = "rbxassetid://1838626744"
-- IDs de las nuevas canciones para el evento brasileño
SOUND_IDS.BrazilMain = "rbxassetid://142376088"
SOUND_IDS.BrazilAfter = "rbxassetid://1838626744"

-- ID de la animación de baile de samba para el jugador
local SAMBA_ANIMATION_ID = "rbxassetid://11994191060"
local sambaAnim = nil

-- ID del modelo del cangrejo de Roblox (objeto de ejemplo)
local CRAB_MODEL_ID = "rbxassetid://1234567890"

local IsAdmin = share.IsAdmin
local playSound = share.playSound
local updateMoneyLabel = share.updateMoneyLabel
local buyItem = share.buyItem
local createMapPart = share.createMapPart

local createOrange = share.createOrange
local createApple = share.createApple
local createGrapes = share.createGrapes
local createPineapple = share.createPineapple
local createWatermelon = share.createWatermelon
local createDragonFruit = share.createDragonFruit
local createCosmicStar = share.createCosmicStar
local createTimeSphere = share.createTimeSphere
local createFruit = share.createFruit

-- FUNCION PARA MOVER FRUTAS (copiado exactamente del original)
local function moveFruit(fruit)
    if not fruit or not fruit.Parent then
        warn("Fruta no válida para mover")
        return
    end
    
    local primaryPart = fruit.PrimaryPart
    if not primaryPart then
        warn("Error: PrimaryPart falló para " .. fruit.Name)
        return
    end
    
    primaryPart.Anchored = true
    primaryPart.CanCollide = false
    
    local startPos = FRUIT_SPAWN_POINT
    local endPos = FRUIT_END_POINT
    
    -- Asegurar que la fruta se posiciona correctamente
    if fruit.PrimaryPart then
        fruit:SetPrimaryPartCFrame(CFrame.new(startPos))
    end
    
    local totalTime = 35
    local startTime = tick()
    local connection
    
    connection = RunService.Heartbeat:Connect(function()
        if not fruit or not fruit.Parent or not fruit.PrimaryPart then
            if connection then connection:Disconnect() end
            return
        end
        
        local elapsed = tick() - startTime
        local progress = math.min(elapsed / totalTime, 1)
        
        local currentPos = startPos:Lerp(endPos, progress)
        local rotation = CFrame.Angles(0, math.rad(360 * progress * 2), 0)
        
        -- Usar SetPrimaryPartCFrame para mover toda la fruta
        fruit:SetPrimaryPartCFrame(CFrame.new(currentPos) * rotation)
        
        if progress >= 1 then
            connection:Disconnect()
            task.spawn(function()
                task.wait(1)
                if fruit and fruit.Parent then
                    fruit:Destroy()
                end
            end)
        end
    end)
end

local function startFruitSpawn()
    if isSpawning then return end
    isSpawning = true
    
    print("Iniciando sistema de spawn de frutas...")
    
    task.spawn(function()
        while isSpawning do
            local ok, err = pcall(function()
                -- Verificar que las funciones y variables necesarias estén disponibles
                if not createFruit or not FRUIT_SPAWN_POINT then
                    warn("createFruit o FRUIT_SPAWN_POINT no están disponibles")
                    return
                end
                
                local fruit = createFruit(FRUIT_SPAWN_POINT)
                if fruit and fruit.Parent then
                    print("Fruta creada: " .. fruit.Name)
                    
                    -- Esperar un poco para que la fruta se configure completamente
                    task.wait(0.5)
                    
                    if fruit and fruit.Parent and fruit.PrimaryPart then
                        print("Iniciando movimiento de fruta: " .. fruit.Name)
                        task.spawn(function()
                            moveFruit(fruit)
                        end)
                    else
                        warn("Fruta no está lista para moverse: " .. (fruit and fruit.Name or "nil"))
                        if fruit and fruit.Parent then 
                            fruit:Destroy() 
                        end
                    end
                else
                    warn("No se pudo crear la fruta")
                end
            end)
            
            if not ok then
                warn("Error al crear fruta: " .. tostring(err))
            end
            
            task.wait(FRUIT_SPAWN_DELAY or 5) -- Usar valor por defecto si FRUIT_SPAWN_DELAY no está definido
        end
    end)
end

-- FUNCIÓN PARA CREAR BASES (copiada exactamente)
local function createBase(player, pos, orientation)
    local baseModel = Instance.new("Model")
    baseModel.Name = player.Name .. "_Base"
    baseModel.Parent = basesFolder
    baseModel:SetAttribute("Owner", player.UserId)
    
    local baseCFrame = CFrame.new(pos) * CFrame.fromEulerAnglesXYZ(math.rad(orientation.X), math.rad(orientation.Y), math.rad(orientation.Z))
    
    local basePlatform = Instance.new("Part")
    basePlatform.Size = Vector3.new(BASE_SIZE.X, 1, BASE_SIZE.Z)
    basePlatform.CFrame = baseCFrame * CFrame.new(0, 0.5, 0) -- Elevamos 0.5 studs para evitar conflicto
    basePlatform.Anchored = true
    basePlatform.Color = Color3.fromRGB(0, 150, 0)
    -- [[ CAMBIO ]] Se cambió el material a Plastic y se añadieron studs (cuadraditos) para el estilo clásico.
    basePlatform.Material = Enum.Material.Plastic
    basePlatform.TopSurface = Enum.SurfaceType.Studs
    basePlatform.Name = "BasePlatform"
    basePlatform.Parent = baseModel
    
    local wallHeight = 25
    local wallWidth = 1
    local wallColor = Color3.fromRGB(100, 100, 100)
    local glassColor = Color3.fromRGB(100, 200, 255)
    
    local roof = Instance.new("Part")
    roof.Size = Vector3.new(BASE_SIZE.X, 1, BASE_SIZE.Z)
    roof.CFrame = baseCFrame * CFrame.new(0, wallHeight + 0.5, 0)
    roof.Anchored = true
    roof.Color = Color3.fromRGB(50, 50, 50)
    roof.Parent = baseModel
    
    local wallLeft = Instance.new("Part")
    wallLeft.Size = Vector3.new(wallWidth, wallHeight, BASE_SIZE.Z)
    wallLeft.CFrame = baseCFrame * CFrame.new(-BASE_SIZE.X/2 + wallWidth/2, wallHeight/2, 0)
    wallLeft.Anchored = true
    wallLeft.Color = wallColor
    wallLeft.Name = "WallLeft"
    wallLeft.Parent = baseModel
    
    local wallRightHeight = 12
    local wallRightLower = Instance.new("Part")
    wallRightLower.Size = Vector3.new(wallWidth, wallRightHeight, BASE_SIZE.Z)
    wallRightLower.CFrame = baseCFrame * CFrame.new(BASE_SIZE.X/2 - wallWidth/2, wallRightHeight/2, 0)
    wallRightLower.Anchored = true
    wallRightLower.Color = glassColor
    wallRightLower.Transparency = 0.5
    wallRightLower.Material = Enum.Material.Glass
    wallRightLower.Name = "WallRightLower"
    wallRightLower.Parent = baseModel
    
    local wallRightUpper = Instance.new("Part")
    wallRightUpper.Size = Vector3.new(wallWidth, wallRightHeight, BASE_SIZE.Z)
    wallRightUpper.CFrame = baseCFrame * CFrame.new(BASE_SIZE.X/2 - wallWidth/2, wallHeight - (wallRightHeight/2), 0)
    wallRightUpper.Anchored = true
    wallRightUpper.Color = glassColor
    wallRightUpper.Transparency = 0.5
    wallRightUpper.Material = Enum.Material.Glass
    wallRightUpper.Name = "WallRightUpper"
    wallRightUpper.Parent = baseModel
    
    local wallBack = Instance.new("Part")
    wallBack.Size = Vector3.new(BASE_SIZE.X, wallHeight, wallWidth)
    wallBack.CFrame = baseCFrame * CFrame.new(0, wallHeight/2, BASE_SIZE.Z/2 - wallWidth/2)
    wallBack.Anchored = true
    wallBack.Color = wallColor
    wallBack.Name = "WallBack"
    wallBack.Parent = baseModel
    
    local frameColor = Color3.fromRGB(50, 50, 50)
    local frameHeight = 2
    local frameThickness = 1
    
    local frame1 = Instance.new("Part")
    frame1.Size = Vector3.new(BASE_SIZE.X, frameHeight, frameThickness)
    frame1.CFrame = baseCFrame * CFrame.new(0, wallHeight + frameHeight/2, BASE_SIZE.Z/2 - frameThickness/2)
    frame1.Anchored = true
    frame1.Color = frameColor
    frame1.Parent = baseModel
    
    local frame2 = Instance.new("Part")
    frame2.Size = Vector3.new(BASE_SIZE.X, frameHeight, frameThickness)
    frame2.CFrame = baseCFrame * CFrame.new(0, wallHeight + frameHeight/2, -BASE_SIZE.Z/2 + frameThickness/2)
    frame2.Anchored = true
    frame2.Color = frameColor
    frame2.Parent = baseModel
    
    local frame3 = Instance.new("Part")
    frame3.Size = Vector3.new(frameThickness, frameHeight, BASE_SIZE.Z)
    frame3.CFrame = baseCFrame * CFrame.new(BASE_SIZE.X/2 - frameThickness/2, wallHeight + frameHeight/2, 0)
    frame3.Anchored = true
    frame3.Color = frameColor
    frame3.Parent = baseModel
    
    local frame4 = Instance.new("Part")
    frame4.Size = Vector3.new(frameThickness, frameHeight, BASE_SIZE.Z)
    frame4.CFrame = baseCFrame * CFrame.new(-BASE_SIZE.X/2 + frameThickness/2, wallHeight + frameHeight/2, 0)
    frame4.Anchored = true
    frame4.Color = frameColor
    frame4.Parent = baseModel
    
    -- ZONA DE COLECCIÓN VERDE MOVIDA HACIA ATRÁS (CORREGIDO)
    local interiorCollect = Instance.new("Part")
    interiorCollect.Size = Vector3.new(BASE_SIZE.X * 0.98, 0.5, BASE_SIZE.Z * 0.25)
    local zOffset = (BASE_SIZE.Z/2) - (interiorCollect.Size.Z/2) - 8
    interiorCollect.CFrame = baseCFrame * CFrame.new(0, 0.75, zOffset)
    interiorCollect.Anchored = true
    interiorCollect.Color = Color3.fromRGB(0, 200, 0)
    interiorCollect.Name = "InteriorCollection"
    interiorCollect.Parent = baseModel
    
    local fruitQuadSize = Vector3.new(8, 0.5, 8)
    local numQuadsPerSide = 3
    local quadZSpacing = 10
    local quads = {}
    
    local quadXLeft = -BASE_SIZE.X/2 + 10
    local startZ = -(BASE_SIZE.Z/2 - 10)
    for i = 1, numQuadsPerSide do
        local quad = Instance.new("Part")
        quad.Size = fruitQuadSize
        quad.CFrame = baseCFrame * CFrame.new(quadXLeft, 1.2, startZ + (i-1) * quadZSpacing)
        quad.Anchored = true
        quad.Color = Color3.fromRGB(200, 200, 200)
        quad.Material = Enum.Material.Plastic
        quad.Parent = baseModel
        quad.Name = "FruitQuad"..i
        table.insert(quads, quad)
    end
    
    local quadXRight = BASE_SIZE.X/2 - 10
    for i = 1, numQuadsPerSide do
        local quad = Instance.new("Part")
        quad.Size = fruitQuadSize
        quad.CFrame = baseCFrame * CFrame.new(quadXRight, 1.2, startZ + (i-1) * quadZSpacing)
        quad.Anchored = true
        quad.Color = Color3.fromRGB(200, 200, 200)
        quad.Material = Enum.Material.Plastic
        quad.Parent = baseModel
        quad.Name = "FruitQuad"..(i + numQuadsPerSide)
        table.insert(quads, quad)
    end
    
    local lockLasersFolder = Instance.new("Folder", baseModel)
    lockLasersFolder.Name = "LockLasers"
    
    local numLasers = 10
    local laserSpacing = (BASE_SIZE.X - 2) / (numLasers - 1)
    local laserStartX = -BASE_SIZE.X/2 + 1
    local laserHeight = wallHeight - 1
    
    for i = 1, numLasers do
        local laser = Instance.new("Part")
        laser.Size = Vector3.new(0.5, laserHeight, 0.5)
        local frontZ = -BASE_SIZE.Z/2 + 0.75
        laser.CFrame = baseCFrame * CFrame.new(laserStartX + (i-1) * laserSpacing, laserHeight/2 + 1, frontZ)
        laser.Anchored = true
        laser.CanCollide = false
        laser.Transparency = 1
        laser.Color = Color3.fromRGB(255, 0, 0)
        laser.Material = Enum.Material.Neon
        laser.Name = "LockLaser"
        laser.Parent = lockLasersFolder
        
        laser.Touched:Connect(function(hit)
            local character = hit.Parent
            local playerHit = Players:GetPlayerFromCharacter(character)
            if playerHit and playerHit.UserId ~= player.UserId then
                if laser.Transparency < 1 then
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        print(playerHit.Name .. " ha tocado un láser de la base de " .. player.Name .. " y va a morir.")
                        humanoid.Health = 0
                    end
                end
            end
        end)
    end
    
    local isLocked = false
    local debounce = false
    
    local lockButton = Instance.new("Part")
    lockButton.Size = Vector3.new(20, 0.5, 5)
    lockButton.Shape = Enum.PartType.Block
    lockButton.CFrame = baseCFrame * CFrame.new(0, 1.5, -BASE_SIZE.Z/2 + 3)
    lockButton.Anchored = true
    lockButton.Color = Color3.fromRGB(0, 255, 0)
    lockButton.Material = Enum.Material.Neon
    lockButton.Name = "LockButton"
    lockButton.Parent = baseModel
    
    local timerGui = Instance.new("BillboardGui", lockButton)
    timerGui.Size = UDim2.new(0, 100, 0, 50)
    timerGui.StudsOffset = Vector3.new(0, 3, 0)
    timerGui.AlwaysOnTop = true
    timerGui.Adornee = lockButton
    timerGui.Enabled = false
    timerGui.Parent = lockButton
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Size = UDim2.new(1,0,1,0)
    mainFrame.BackgroundTransparency = 0
    mainFrame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    mainFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    mainFrame.BorderSizePixel = 2
    mainFrame.Parent = timerGui
    
    local timerLabel = Instance.new("TextLabel", mainFrame)
    timerLabel.Size = UDim2.new(1, 0, 1, 0)
    timerLabel.Text = "Bloqueado: 0s"
    timerLabel.TextScaled = true
    timerLabel.Font = Enum.Font.SourceSansBold
    timerLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    timerLabel.BackgroundTransparency = 1
    timerLabel.Parent = mainFrame
    
    lockButton.Touched:Connect(function(hit)
        local playerHit = Players:GetPlayerFromCharacter(hit.Parent)
        if playerHit and playerHit == player and not isLocked and not debounce then
            debounce = true
            isLocked = true
            
            for _, laser in ipairs(lockLasersFolder:GetChildren()) do
                laser.CanCollide = true
                laser.Transparency = 0
            end
            
            print("Base bloqueada por " .. player.Name .. " durante " .. LOCK_LASER_TIME .. " segundos.")
            
            timerGui.Enabled = true
            local remainingTime = LOCK_LASER_TIME
            task.spawn(function()
                while remainingTime > 0 do
                    timerLabel.Text = "Bloqueado: " .. tostring(remainingTime) .. "s"
                    remainingTime = remainingTime - 1
                    task.wait(1)
                end
                isLocked = false
                debounce = false
                timerGui.Enabled = false
                for _, laser in ipairs(lockLasersFolder:GetChildren()) do
                    laser.CanCollide = false
                    laser.Transparency = 1
                end
            end)
        end
    end)
    
    local collectionZone = Instance.new("Folder", baseModel)
    collectionZone.Name = "CollectionZone"
    
    local featureSize = Vector3.new(5, 5, 5)
    local center = interiorCollect.Position
    local radius = BASE_SIZE.X * 0.25
    
    -- Las funciones de velocidad e invisibilidad ahora están en la tienda
    -- Esta zona ahora está libre para otros usos futuros
    
    playerData[player] = {Money = 100, Base = baseModel, Brainrots = {}}
    return baseModel
end

local function createMap()
    local baseplate = Workspace:FindFirstChild("Baseplate")
    if baseplate then
        baseplate:Destroy()
    end
    
    local mapSize = 250
    -- [[ CAMBIO ]] Se cambió el material del suelo a Plastic.
    createMapPart(Vector3.new(mapSize, 1, mapSize), Vector3.new(0, 0, 0), Color3.fromRGB(0, 200, 0), Enum.Material.Plastic, mapFolder, "Floor")
    -- [[ CAMBIO ]] Se añaden los studs (cuadraditos) al suelo del mapa.
    local mapFloor = mapFolder:FindFirstChild("Floor")
    if mapFloor then
        mapFloor.TopSurface = Enum.SurfaceType.Studs
    end
    
    local wallSize = Vector3.new(mapSize, 50, 2)
    local wallColor = Color3.fromRGB(139, 69, 19)
    local wallOffset = mapSize / 2
    
    -- [[ CAMBIO ]] Se cambió el material de las paredes y bordes a Plastic.
    createMapPart(wallSize, Vector3.new(0, 25, -wallOffset), wallColor, Enum.Material.Plastic, mapFolder, "WallBack")
    createMapPart(wallSize, Vector3.new(0, 25, wallOffset), wallColor, Enum.Material.Plastic, mapFolder, "WallFront")
    createMapPart(Vector3.new(2, 50, mapSize), Vector3.new(wallOffset, 25, 0), wallColor, Enum.Material.Plastic, mapFolder, "WallRight")
    createMapPart(Vector3.new(2, 50, mapSize), Vector3.new(-wallOffset, 25, 0), wallColor, Enum.Material.Plastic, mapFolder, "WallLeft")
    
    local borderColor = Color3.fromRGB(0, 150, 0)
    createMapPart(Vector3.new(mapSize, 3, 2), Vector3.new(0, 51.5, -wallOffset), borderColor, Enum.Material.Plastic, mapFolder, "BackBorder")
    createMapPart(Vector3.new(mapSize, 3, 2), Vector3.new(0, 51.5, wallOffset), borderColor, Enum.Material.Plastic, mapFolder, "FrontBorder")
    createMapPart(Vector3.new(2, 3, mapSize), Vector3.new(wallOffset, 51.5, 0), borderColor, Enum.Material.Plastic, mapFolder, "RightBorder")
    createMapPart(Vector3.new(2, 3, mapSize), Vector3.new(-wallOffset, 51.5, 0), borderColor, Enum.Material.Plastic, mapFolder, "LeftBorder")
    
    createMapPart(Vector3.new(20, 0.5, 250), Vector3.new(0, 1.01, 0), Color3.fromRGB(255, 0, 0), Enum.Material.Plastic, mapFolder, "CentralArea")
    
    -- Seccion del tunel arreglada para evitar que las paredes se superpongan
    local function createTunnel(zPosition, nameSuffix)
        local tunnelHeight = 15
        local tunnelWidth = 22 -- Aumentamos ligeramente para mejor proporción
        local wallHeight = 50
        local wallColor = Color3.fromRGB(139, 69, 19)
        local entranceBorderColor = Color3.fromRGB(100, 100, 100)
        local mapWidth = 250
        
        -- Calculamos mejor las posiciones para evitar conflictos
        local totalSideWallWidth = mapWidth - tunnelWidth - 4 -- Más separación
        local sideWallWidth = totalSideWallWidth / 2
        local sideWallOffset = (tunnelWidth/2) + (sideWallWidth/2) + 2
        
        -- [[ CAMBIO ]] Se cambió el material de las partes del túnel a Plastic.
        -- Crea la parte izquierda de la pared, dejando un hueco para el túnel
        createMapPart(Vector3.new(sideWallWidth, wallHeight, 2), Vector3.new(-sideWallOffset, wallHeight/2, zPosition), wallColor, Enum.Material.Plastic, mapFolder, "WallLeft"..nameSuffix)
        -- Crea la parte derecha de la pared
        createMapPart(Vector3.new(sideWallWidth, wallHeight, 2), Vector3.new(sideWallOffset, wallHeight/2, zPosition), wallColor, Enum.Material.Plastic, mapFolder, "WallRight"..nameSuffix)
        
        -- Crea la parte de arriba del túnel para formar el hueco - Mejor posicionada
        createMapPart(Vector3.new(tunnelWidth, 6, 2), Vector3.new(0, tunnelHeight + 3, zPosition), entranceBorderColor, Enum.Material.Plastic, mapFolder, "TopBorder"..nameSuffix)
        -- Crea los bordes de los lados del túnel - Mejor alineados
        createMapPart(Vector3.new(3, tunnelHeight, 2), Vector3.new(-(tunnelWidth/2 + 1.5), tunnelHeight/2 + 1, zPosition), entranceBorderColor, Enum.Material.Plastic, mapFolder, "LeftBorder"..nameSuffix)
        createMapPart(Vector3.new(3, tunnelHeight, 2), Vector3.new((tunnelWidth/2 + 1.5), tunnelHeight/2 + 1, zPosition), entranceBorderColor, Enum.Material.Plastic, mapFolder, "RightBorder"..nameSuffix)
    end
    
    createTunnel(wallOffset, "Front")
    createTunnel(-wallOffset, "Back")
    
    -- [[ CAMBIO ]] Se cambió el material del letrero a Plastic.
    local leaderboardSign = createMapPart(Vector3.new(20, 15, 1), Vector3.new(-100, 25, wallOffset - 3), Color3.fromRGB(50, 50, 50), Enum.Material.Plastic, mapFolder, "LeaderboardSign", false)
    
    local leaderboardGui = Instance.new("BillboardGui")
    leaderboardGui.Size = UDim2.new(0, 100, 0, 75)
    leaderboardGui.Adornee = leaderboardSign
    leaderboardGui.Parent = leaderboardSign
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Size = UDim2.new(1, 0, 1, 0)
    mainFrame.BackgroundTransparency = 1
    mainFrame.Parent = leaderboardGui
    
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, 0, 0.2, 0)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.Text = "Mejores Jugadores"
    titleLabel.TextScaled = true
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Parent = mainFrame
    
    local playerList = Instance.new("Frame")
    playerList.Size = UDim2.new(1, 0, 0.8, 0)
    playerList.Position = UDim2.new(0, 0, 0.2, 0)
    playerList.BackgroundTransparency = 1
    playerList.Parent = mainFrame
    
    local listLayout = Instance.new("UIListLayout")
    listLayout.Padding = UDim.new(0, 5)
    listLayout.VerticalAlignment = Enum.VerticalAlignment.Top
    listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    listLayout.Parent = playerList
    
    local function updateLeaderboard()
        for _, child in ipairs(playerList:GetChildren()) do
            if child:IsA("TextLabel") then
                child:Destroy()
            end
        end
        
        local sortedPlayers = {}
        for player, data in pairs(playerData) do
            table.insert(sortedPlayers, {player = player, money = data.Money})
        end
        
        table.sort(sortedPlayers, function(a, b)
            return a.money > b.money
        end)
        
        for i, entry in ipairs(sortedPlayers) do
            if i > 5 then break end
            
            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, 0, 0.2, 0)
            label.Text = i .. ". " .. entry.player.Name .. " - $" .. entry.money
            label.TextScaled = true
            label.Font = Enum.Font.SourceSansBold
            label.TextColor3 = Color3.fromRGB(255, 255, 255)
            label.BackgroundTransparency = 1
            label.Parent = playerList
        end
    end
    
    task.spawn(function()
        while task.wait(LEADERBOARD_UPDATE_INTERVAL) do
            updateLeaderboard()
        end
    end)
    
    local music = Instance.new("Sound", Workspace)
    music.Name = "BackgroundMusic"
    music.SoundId = SOUND_IDS.BackgroundMusic
    music.Looped = true
    music.Volume = 0.5
    pcall(function() music:Play() end)
        
        -- TIENDA REDISEÑADA
        local SHOP_POSITION = Vector3.new(80, 1, 100) -- Posición ajustada para evitar paredes
        local SHOP_ITEMS = {
        ["Velocidad x2"] = {Price = 150, Stat = "WalkSpeed", Value = 10, Name = "Velocidad x2", Duration = 30},
        ["Invisibilidad"] = {Price = 200, Stat = "Invisible", Value = 1, Name = "Invisibilidad", Duration = 25}
        }
        
        local shop = Instance.new("Model")
        shop.Name = "Shop"
        shop.Parent = mapFolder
        
        -- [[ CAMBIO ]] Se cambió el material del suelo de la tienda a Plastic.
        local shopFloor = createMapPart(Vector3.new(24, 1, 24), SHOP_POSITION, Color3.fromRGB(139, 69, 19), Enum.Material.Plastic, shop, "ShopFloor")
        -- [[ CAMBIO ]] Se añadieron los studs (cuadraditos) al suelo de la tienda.
        if shopFloor then
            shopFloor.TopSurface = Enum.SurfaceType.Studs
        end
        
        -- Paredes de la tienda (estilo cuadradito de Roblox)
        local wallHeight = 12
        local wallThickness = 1
        local wallColor = Color3.fromRGB(255, 255, 255)
        
        -- [[ CAMBIO ]] Se cambió el material de todas las partes de la tienda a Plastic.
        -- Paredes principales con material cuadradito
        createMapPart(Vector3.new(24, wallHeight, wallThickness), SHOP_POSITION + Vector3.new(0, wallHeight/2, 12), wallColor, Enum.Material.Plastic, shop, "WallBack")
        createMapPart(Vector3.new(24, wallHeight, wallThickness), SHOP_POSITION + Vector3.new(0, wallHeight/2, -12), wallColor, Enum.Material.Plastic, shop, "WallFront")
        createMapPart(Vector3.new(wallThickness, wallHeight, 24), SHOP_POSITION + Vector3.new(12, wallHeight/2, 0), wallColor, Enum.Material.Plastic, shop, "WallRight")
        
        -- Pared izquierda con entrada (sin superposición)
        createMapPart(Vector3.new(wallThickness, wallHeight, 7), SHOP_POSITION + Vector3.new(-12, wallHeight/2, 8.5), wallColor, Enum.Material.Plastic, shop, "WallLeftBack")
        createMapPart(Vector3.new(wallThickness, wallHeight, 7), SHOP_POSITION + Vector3.new(-12, wallHeight/2, -8.5), wallColor, Enum.Material.Plastic, shop, "WallLeftFront")
        
        -- Marco de la entrada mejorado
        createMapPart(Vector3.new(wallThickness, 3, 10), SHOP_POSITION + Vector3.new(-12, wallHeight - 1.5, 0), Color3.fromRGB(139, 69, 19), Enum.Material.Plastic, shop, "DoorFrame")
        
        -- Techo rojo
        createMapPart(Vector3.new(26, 1, 26), SHOP_POSITION + Vector3.new(0, wallHeight + 0.5, 0), Color3.fromRGB(220, 20, 60), Enum.Material.Plastic, shop, "Roof")
        
        -- Bordes del techo (blancos) - ajustados para no superponerse
        createMapPart(Vector3.new(28, 1, 2), SHOP_POSITION + Vector3.new(0, wallHeight + 1, 13), Color3.fromRGB(255, 255, 255), Enum.Material.Plastic, shop, "RoofBorderBack")
        createMapPart(Vector3.new(28, 1, 2), SHOP_POSITION + Vector3.new(0, wallHeight + 1, -13), Color3.fromRGB(255, 255, 255), Enum.Material.Plastic, shop, "RoofBorderFront")
        createMapPart(Vector3.new(2, 1, 28), SHOP_POSITION + Vector3.new(13, wallHeight + 1, 0), Color3.fromRGB(255, 255, 255), Enum.Material.Plastic, shop, "RoofBorderRight")
        createMapPart(Vector3.new(2, 1, 28), SHOP_POSITION + Vector3.new(-13, wallHeight + 1, 0), Color3.fromRGB(255, 255, 255), Enum.Material.Plastic, shop, "RoofBorderLeft")
        
        -- Columnas decorativas (estilo cuadradito)
        local columnSize = Vector3.new(2, wallHeight, 2)
        local columnColor = Color3.fromRGB(139, 69, 19)
        createMapPart(columnSize, SHOP_POSITION + Vector3.new(8, wallHeight/2, -8), columnColor, Enum.Material.Plastic, shop, "Column1")
        createMapPart(columnSize, SHOP_POSITION + Vector3.new(-8, wallHeight/2, -8), columnColor, Enum.Material.Plastic, shop, "Column2")
        createMapPart(columnSize, SHOP_POSITION + Vector3.new(8, wallHeight/2, 8), columnColor, Enum.Material.Plastic, shop, "Column3")
        createMapPart(columnSize, SHOP_POSITION + Vector3.new(-8, wallHeight/2, 8), columnColor, Enum.Material.Plastic, shop, "Column4")
        
        -- CREAR NPC VENDEDOR
        local npc = Instance.new("Model")
        npc.Name = "ShopNPC"
        npc.Parent = shop
        
        local npcTorso = Instance.new("Part")
        npcTorso.Name = "Torso"
        npcTorso.Size = Vector3.new(2, 2, 1)
        npcTorso.Color = Color3.fromRGB(255, 205, 148)
        npcTorso.Material = Enum.Material.Plastic
        npcTorso.Anchored = true
        npcTorso.CanCollide = false
        npcTorso.Parent = npc
        
        local npcHead = Instance.new("Part")
        npcHead.Name = "Head"
        npcHead.Size = Vector3.new(2, 1, 1)
        npcHead.Color = Color3.fromRGB(255, 205, 148)
        npcHead.Material = Enum.Material.Plastic
        npcHead.Anchored = true
        npcHead.CanCollide = false
        npcHead.Parent = npc
        
        local npcLeftArm = Instance.new("Part")
        npcLeftArm.Name = "Left Arm"
        npcLeftArm.Size = Vector3.new(1, 2, 1)
        npcLeftArm.Color = Color3.fromRGB(255, 205, 148)
        npcLeftArm.Material = Enum.Material.Plastic
        npcLeftArm.Anchored = true
        npcLeftArm.CanCollide = false
        npcLeftArm.Parent = npc
        
        local npcRightArm = Instance.new("Part")
        npcRightArm.Name = "Right Arm"
        npcRightArm.Size = Vector3.new(1, 2, 1)
        npcRightArm.Color = Color3.fromRGB(255, 205, 148)
        npcRightArm.Material = Enum.Material.Plastic
        npcRightArm.Anchored = true
        npcRightArm.CanCollide = false
        npcRightArm.Parent = npc
        
        local npcLeftLeg = Instance.new("Part")
        npcLeftLeg.Name = "Left Leg"
        npcLeftLeg.Size = Vector3.new(1, 2, 1)
        npcLeftLeg.Color = Color3.fromRGB(0, 0, 255)
        npcLeftLeg.Material = Enum.Material.Plastic
        npcLeftLeg.Anchored = true
        npcLeftLeg.CanCollide = false
        npcLeftLeg.Parent = npc
        
        local npcRightLeg = Instance.new("Part")
        npcRightLeg.Name = "Right Leg"
        npcRightLeg.Size = Vector3.new(1, 2, 1)
        npcRightLeg.Color = Color3.fromRGB(0, 0, 255)
        npcRightLeg.Material = Enum.Material.Plastic
        npcRightLeg.Anchored = true
        npcRightLeg.CanCollide = false
        npcRightLeg.Parent = npc
        
        -- Posicionar las partes del NPC
        local npcPosition = SHOP_POSITION + Vector3.new(0, 3, 5)
        npcTorso.CFrame = CFrame.new(npcPosition)
        npcHead.CFrame = CFrame.new(npcPosition + Vector3.new(0, 1.5, 0))
        npcLeftArm.CFrame = CFrame.new(npcPosition + Vector3.new(-1.5, 0, 0))
        npcRightArm.CFrame = CFrame.new(npcPosition + Vector3.new(1.5, 0, 0))
        npcLeftLeg.CFrame = CFrame.new(npcPosition + Vector3.new(-0.5, -2, 0))
        npcRightLeg.CFrame = CFrame.new(npcPosition + Vector3.new(0.5, -2, 0))
        
        -- Camisa del NPC
        local shirt = Instance.new("Shirt")
        shirt.Name = "Shirt"
        shirt.ShirtTemplate = "rbxasset://textures/face.png"
        shirt.Parent = npc
        
        -- Cara del NPC
        local face = Instance.new("Decal")
        face.Name = "face"
        face.Face = Enum.NormalId.Front
        face.Texture = "rbxasset://textures/face.png"
        face.Parent = npcHead
        
        -- Humanoid para el NPC
        local humanoid = Instance.new("Humanoid")
        humanoid.MaxHealth = 100
        humanoid.Health = 100
        humanoid.Parent = npc
        
        npc.PrimaryPart = npcTorso
        
        -- [[ CAMBIO ]] Se cambió el material del tablero de precios a Plastic.
        local priceBoard = createMapPart(Vector3.new(10, 8, 0.2), SHOP_POSITION + Vector3.new(8, wallHeight/2, -11.9), Color3.fromRGB(139, 69, 19), Enum.Material.Plastic, shop, "PriceBoard")
        
        local priceGui = Instance.new("SurfaceGui")
        priceGui.Face = Enum.NormalId.Front
        priceGui.Parent = priceBoard
        
        local priceFrame = Instance.new("Frame")
        priceFrame.Size = UDim2.new(1, 0, 1, 0)
        priceFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        priceFrame.BorderSizePixel = 2
        priceFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
        priceFrame.Parent = priceGui
        
        local titleLabel = Instance.new("TextLabel")
        titleLabel.Size = UDim2.new(1, 0, 0.25, 0)
        titleLabel.Position = UDim2.new(0, 0, 0, 0)
        titleLabel.Text = "🛒 TIENDA 🛒"
        titleLabel.TextScaled = true
        titleLabel.Font = Enum.Font.SourceSansBold
        titleLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
        titleLabel.BackgroundTransparency = 1
        titleLabel.Parent = priceFrame
        
        local speedLabel = Instance.new("TextLabel")
        speedLabel.Size = UDim2.new(1, 0, 0.35, 0)
        speedLabel.Position = UDim2.new(0, 0, 0.25, 0)
        speedLabel.Text = "💨 Velocidad x2\n$150 (30s)"
        speedLabel.TextScaled = true
        speedLabel.Font = Enum.Font.SourceSans
        speedLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
        speedLabel.BackgroundTransparency = 1
        speedLabel.Parent = priceFrame
        
        local invisLabel = Instance.new("TextLabel")
        invisLabel.Size = UDim2.new(1, 0, 0.4, 0)
        invisLabel.Position = UDim2.new(0, 0, 0.6, 0)
        invisLabel.Text = "👻 Invisibilidad\n$200 (25s)"
        invisLabel.TextScaled = true
        invisLabel.Font = Enum.Font.SourceSans
        invisLabel.TextColor3 = Color3.fromRGB(200, 0, 255)
        invisLabel.BackgroundTransparency = 1
        invisLabel.Parent = priceFrame
        
        -- ZONAS DE COMPRA EN LA TIENDA
        
        -- Zona de velocidad
        local speedZone = createMapPart(Vector3.new(6, 0.5, 6), SHOP_POSITION + Vector3.new(-5, 1.25, -5), Color3.fromRGB(0, 255, 255), Enum.Material.ForceField, shop, "SpeedZone")
        
        local speedGui = Instance.new("BillboardGui", speedZone)
        speedGui.Size = UDim2.new(0, 80, 0, 40)
        speedGui.StudsOffset = Vector3.new(0, 3, 0)
        local speedShopLabel = Instance.new("TextLabel", speedGui)
        speedShopLabel.Size = UDim2.new(1, 0, 1, 0)
        speedShopLabel.Text = "💨 Velocidad\n$150"
        speedShopLabel.TextScaled = true
        speedShopLabel.BackgroundTransparency = 1
        speedShopLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
        speedShopLabel.Font = Enum.Font.SourceSansBold
        speedShopLabel.Parent = speedGui
        
        -- Zona de invisibilidad
        local invisZone = createMapPart(Vector3.new(6, 0.5, 6), SHOP_POSITION + Vector3.new(5, 1.25, -5), Color3.fromRGB(200, 0, 255), Enum.Material.ForceField, shop, "InvisZone")
        
        local invisGui = Instance.new("BillboardGui", invisZone)
        invisGui.Size = UDim2.new(0, 80, 0, 40)
        invisGui.StudsOffset = Vector3.new(0, 3, 0)
        local invisShopLabel = Instance.new("TextLabel", invisGui)
        invisShopLabel.Size = UDim2.new(1, 0, 1, 0)
        invisShopLabel.Text = "👻 Invisible\n$200"
        invisShopLabel.TextScaled = true
        invisShopLabel.BackgroundTransparency = 1
        invisShopLabel.TextColor3 = Color3.fromRGB(200, 0, 255)
        invisShopLabel.Font = Enum.Font.SourceSansBold
        invisShopLabel.Parent = invisGui
        
        -- Función para comprar velocidad
        local speedCooldowns = {}
        speedZone.Touched:Connect(function(hit)
            local playerHit = Players:GetPlayerFromCharacter(hit.Parent)
            if playerHit and playerData[playerHit] and not speedCooldowns[playerHit] then
                local item = SHOP_ITEMS["Velocidad x2"]
                if playerData[playerHit].Money >= item.Price then
                    speedCooldowns[playerHit] = true
                    
                    playerData[playerHit].Money = playerData[playerHit].Money - item.Price
                    updateMoneyLabel(playerHit)
                    
                    local humanoid = playerHit.Character and playerHit.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid:GetAttribute("SpeedBoostActive") == nil then
                        humanoid:SetAttribute("SpeedBoostActive", true)
                        local originalSpeed = humanoid.WalkSpeed
                        humanoid.WalkSpeed = (originalSpeed or 16) + item.Value
                        
                        -- Efecto visual
                        speedZone.Color = Color3.fromRGB(255, 255, 0)
                        
                        SpeedBoostEvent:FireClient(playerHit, item.Duration)
                        
                        task.delay(item.Duration, function()
                            if humanoid and humanoid.Parent then
                                humanoid.WalkSpeed = originalSpeed
                                humanoid:SetAttribute("SpeedBoostActive", nil)
                                speedZone.Color = Color3.fromRGB(0, 255, 255)
                            end
                        end)
                    end
                    
                    task.delay(2, function()
                        speedCooldowns[playerHit] = nil
                    end)
                else
                    -- Mensaje de dinero insuficiente
                    print(playerHit.Name .. " no tiene suficiente dinero para comprar velocidad")
                end
            end
        end)
        
        -- Función para comprar invisibilidad
        local invisCooldowns = {}
        invisZone.Touched:Connect(function(hit)
            local playerHit = Players:GetPlayerFromCharacter(hit.Parent)
            if playerHit and playerData[playerHit] and not invisCooldowns[playerHit] then
                local item = SHOP_ITEMS["Invisibilidad"]
                if playerData[playerHit].Money >= item.Price then
                    invisCooldowns[playerHit] = true
                    
                    playerData[playerHit].Money = playerData[playerHit].Money - item.Price
                    updateMoneyLabel(playerHit)
                    
                    local char = playerHit.Character
                    if char and char:GetAttribute("InvisibleActive") == nil then
                        char:SetAttribute("InvisibleActive", true)
                        
                        -- Efecto visual
                        invisZone.Color = Color3.fromRGB(255, 0, 255)
                        
                        -- Aplicar invisibilidad
                        local originalTransparencies = {}
                        for _, part in ipairs(char:GetDescendants()) do
                            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                                originalTransparencies[part] = part.Transparency
                                part.Transparency = 0.9
                            elseif part:IsA("Decal") or part:IsA("ShirtGraphic") then
                                originalTransparencies[part] = part.Transparency
                                part.Transparency = 1
                            end
                        end
                        
                        InvisibilityEvent:FireClient(playerHit, item.Duration)
                        
                        task.delay(item.Duration, function()
                            -- Restaurar transparencias
                            for part, transparency in pairs(originalTransparencies) do
                                if part and part.Parent then
                                    part.Transparency = transparency
                                end
                            end
                            
                            invisZone.Color = Color3.fromRGB(200, 0, 255)
                            char:SetAttribute("InvisibleActive", nil)
                        end)
                    end
                    
                    task.delay(2, function()
                        invisCooldowns[playerHit] = nil
                    end)
                else
                    print(playerHit.Name .. " no tiene suficiente dinero para comprar invisibilidad")
                end
            end
        end)
        
        -- ProximityPrompt en el NPC (solo para saludar)
        local shopPrompt = Instance.new("ProximityPrompt", npcTorso)
        shopPrompt.ActionText = "Hablar con vendedor"
        shopPrompt.ObjectText = "¡Hola! Usa las zonas para comprar"
        shopPrompt.HoldDuration = 0.5
        shopPrompt.MaxActivationDistance = 10
        shopPrompt.RequiresLineOfSight = false
        
        shopPrompt.Triggered:Connect(function(player)
            print(player.Name .. " habló con el vendedor")
            
            -- Animación simple del NPC
            local originalPos = npcTorso.CFrame
            local tween = TweenService:Create(npcTorso, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
            CFrame = originalPos * CFrame.Angles(0, math.rad(10), 0)
            })
            tween:Play()
            tween.Completed:Connect(function()
                local returnTween = TweenService:Create(npcTorso, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                CFrame = originalPos
                })
                returnTween:Play()
            end)
        end)
    end
